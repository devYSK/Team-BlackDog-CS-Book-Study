# 4.5 인덱스



인덱스는 데이터를 빠르게 찾기 위해 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.

  


인덱스를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. 

* UPDATE나 DELETE 연산을 수행하려면 먼저, 해당 대상이 존재하는지 조회해야만 작업을 할 수 있기 때문이다.

  


만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Table Full Scan을 수행해야 한다.   

* 인덱스가 없기 때문에 

* Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

   




index를 항상 최신, 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.  
최신 정렬 상태로 유지해야 하기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.

- INSERT: 새로운 데이터에 대한 인덱스를 추가
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가

 

> 그러므로 인덱스가 SELECT에는 빠르나 INSERT, DELETE, UPDATE에는 느리다 라고 할 수 있다.

  


#### 인덱스의 장점 / 단점 

- 장점
  - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
  - 전반적인 시스템의 부하를 줄일 수 있다.
- 단점
  - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 추가적인 저장공간이 필요하다.
  - 인덱스를 관리하기 위해 추가 작업이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.



>  만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다. 

 

---

#### 인덱스를 사용하면 좋은 경우 

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼 - 조회
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼 - 조회
- 데이터의 중복도가 낮은 컬럼 - 내부적으로 Key,Value의 트리 형태로 데이터를 저장하는데, 데이터(Key)가 중복되어 여러개 존재하면 검색되는 대상이 증가하기 때문



인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 

그러므로 사용되지 않는 인덱스는 바로 제거를 해주어야 한다. 

[참조](https://mangkyu.tistory.com/96)

## B-TREE



인덱스는 보통 B-트리라는 자료구조로 이루어져 있다.

검색을 위한 자료구조중에서 이진트리는 한 부모가 두 개의 자식밖에 가지질 못하고, 균형이 맞지 않으면 검색 효율이 선형(O(n)) 급으로 떨어지지만, 균형이 잘맞으면 성능이 O(log N) 수준으로 보이는 장점이 있어 이를 바탕으로 개선하고자 하는 자료구조들이 나왔습니다.

B Tree는 이진트리를 확장해서 더 많은수의 자식을 가질 수 있고, 균형이 맞지 않는 편향트리가 되지 않도록 균형을 맞추는 구조를 갖고 있습니다.

데이터베이스, 파일 시스템에서 널리 사용되는 트리 자료구조의 일종입니다.

단순하고 효율적이며 레벨로만 따지면 완전히 균형을 맞춘 트리입니다.

대량의 데이터를 처리할 때 하나의 노드에 많은 데이터를 가질 수 있으므로 큰 장점을 갖고 있습니다.

## B Tree의 규칙

* M차 트리일 때, 루트 노드와 리프노드 를 제외한 모든 node는 `최소 [M/2, 천정함수]`, `최대 M개`의 서브 트리를 갖는다.

  * 최소의 [M/2 천정함수, ceil] : 반올림값 이라고 이해하면 편하다. 1.5 -> 2 / 2.5 ->3
  * M = 자식수 * 2  - 1 (M = 2t -1)   

* 루트 노드는 적어도 2개 이상의 자식을 가져야 한다.

  * 노드의 데이터 개수가 n개라면 자식 노드의 개수는 n + 1
  * 최소차수는 자식수의 하한값을 의미
  * 자식 수가 t 이면 M = 2t - 1 (최소차수가 2라면 M은 3이고, 이 트리는 3차 B tree )

* 각 노드의 자료수가 N이면 자식 수는 N+1 이여야 한다.

  * key 수 = 자료(data) 수
  * 노드에 2개의 키가 있으면 자식 수는 2 + 1 = 3이다.
  * 아래 그림에서는 9, 11 노드가 8, 10, 12,14 노드를 가리켜서 4개 같지만 4개가 아니다.
  * 8 노드, 10 노드, 그리고 12와 14가 묶은 한 노드인 총 3개의 노드를 가리키고 있는것이다. 

* 각 노드의 자료는 정렬된 상태여야 한다.

* 각 노드에는 key 값이 2개 이상 들어갈 수 있다. 

* 최대 M개의 자식을 가질 수 있는 B 트리를 M차 B트리라고 한다. 

  * M : 자식을 가질수 있는 숫자 = B트리의 차수

* 외부 노드로 가는 경로의 길이는 모두 같다. - 외부 노드는 모두 같은 레벨에 있다. 

* 입력 자료는 중복될 수 없다. 

  

* <img src = "https://blog.kakaocdn.net/dn/3XP3x/btrJBJPi1GP/bvWtvcICkLGrIqucIhxsN1/img.png">



* 키, 포인터를 가진다.
* 그림에서 숫자는 각 노드의 key이다
* key 옆의 진한 주황색 부분은 각 자식들을 가르키는 포인터이다.

* BST의처럼 각 노드의 왼쪽 자식 노드들의 key 값은 부모 노드보다 작으며 오른쪽 자식 노드들의 key값은 부모 노드보다 크다.



## B Tree의 조회

1. 루트노드에서 시작하여 이진트리와 같이 검색을 수행합니다.
   * BST의 특성으로 자기자신보다 작은값은 왼쪽, 큰값은 오른쪽에 있습니다
   * 하지만 B Tree는 한 노드에 2개이상의 키를 가지고 있을 수 있기 때문에 그 사이에 있는 값인지도 체크 해야합니다.
2. 특정한 key들 사이에 찾는 값이 존재한다면 해당 key들 사이의 자식 노드로 내려갑니다.
   * 위 그림에서 9를 찾는다면, 루트노드의 키인 7, 15중 7보단 크고 15보단 작으므로 가운데 노드로 내려가서 찾습니다.

3. 해당 과정을 리프노드에 도달할 때 까지 반복. 만일 리프노드에서도 키가 없다면 검색은 실패. 



 ## B Tree의 삽입

1. 자료는 항상 리프 노드에만 삽입된다.
2. 리프 노드의 선택은 루트 노드부터 시작해 하향식으로 탐색한다.
3. 선택한 리프 노드에 여유가 있다면 그냥 삽입. 
4. 삽입하려는 위치의 노드가 가득 찼다면, `노드를 분할하고 생성`
5. 노드가 분할되는 경우 노드의 중앙값을 기준으로 분할.
   * 중앙값은 부모 노드로 합쳐지거나 새로운 노드로 생성된다.
   * 중앙값을 기준으로 왼쪽의 key는 왼쪽 자식, 오른쪽 key는 오른쪽 자식으로 삽입.

* https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree

* [홀수일때와 짝수일때의 삽입/삭제과정](https://swycha.tistory.com/236)

## B Tree의 삭제

리프 노드와 리프 노드가 아닐 경우 두가지로 나뉘고, 두 가지 경우 내에서 또 여러 가지 경우로 나뉜다.

 노드를 찾았다면 데이터 삭제 후, 노드에 너무 적은 수의 데이터가 남지 않도록 해야 합니다.  (M/2 이상 보장)  만일 데이터 수가 부족하다면 형제에게서 데이터를 빌리거나 형제와 결합한다.

* https://rebro.kr/169
* https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree



## B Tree 성능

B Tree의 탐색 시간복잡도는 O(lonN)

* B-트리는 자동으로 균형을 잡기 때문에 최악의 경우에도 O(logN) 성능을 보장한다. 

- 노드의 삽입/삭제 후에도 균등한 응답 속도를 보장한다
- 단점 : 삽입/ 삭제시 균형 유지를 위해 복잡한 연산이 필요하다. 

```
데이터 로드 효율성 측면은 대량의 데이터로 트리를 구성할 때, 진가를 발휘한다. 
데이터가 많은경우 메모리에 트리 구조를 유지하기 보다는 외부장치에 데이터를 저장해야 한다. 
각 노드의 값을 파일로 저장한 후, 파일 정보만 저장하고 있다면 메모리에서도 충분히 트리를 유지할 수 있게 된다. 
외부장치에서 데이터를 읽어올때 데이터가 크던 작던 블럭 크기 만큼 읽어온다. 
즉 노드의 데이터를 특정 블럭 크기 만큼 지정하여 저장 할 수 있다면 효율적으로 데이터를 읽어올 수 있다는 장점이 생긴다.
```



### 인덱스가 효율적인 이유와 대수확장성



균형잡힌 B-Tree기반으로 구축되어있어서 탐색에 평균 O(logN) 시간이 걸린다



- 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미
- 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가
- 아래와 같이 트리 깊이는 열개짜리로, 100만개 레코드를 검색 가능(실제 인덱스는 이 것보다 훨씬 효율적)



### 인덱스를 만드는 방법



### MySQL

MySQL 의 경우 클러스터형 인덱스와 세컨더리 인덱스가 있다.

* 클러스터형 인덱스 (기본 인덱스) - 테이블당 하나 설정. 
  * primary key 옵션으로 기본키를 만들면 클러스터형 인덱스 생성
  * 기본키로 만들지 않고 unique not null 옵션을 붙여도 클러스터형 인덱스
  * MySQL 에선 Primary Key 가 있는 경우 Primary Key , 없으면 UNIQUE 하면서 NOT NULL 인 컬럼 , 그것도 없다면 임의로 보이지 않는 컬럼을 만들어서 Clustered Index 로 지정
  * 인덱스 생성방법
    * primary key : 클러스터형
    * alter table add primary key

* 세컨더리 인덱스 (보조 인덱스)  - 테이블 당 **여러개** 생성 가능
  * Primary Key 이외에 필요한 정렬 기준이 있을 경우 사용한다. 
  * unique 하지 않아도 된다. 
  * 정렬되어있지 않아서 클러스터형 보다 검색 속도는 더 느리지만 데이터의 입력/수정/삭제는 덜 느리다.
  * 조건절에 컬럼이 많이 들어간다면 세컨더리 인덱스를 사용하는것이 좋다
  * 보조 인덱스를 만드는 방법
    * create index ..
    * alter table add index



### MongoDB

* 도큐먼트를 만들면 자동으로 ObjectID가 형성되며 해당 키가 기본키로 설정된다.
* index는 한 쿼리에 한 index만 유효하다. 따라서 두 개의 index 가 필요하다면 복합 index를 사용한다.



### 인덱스 최적화 기법



#### MySQL



1.  1개의 컬럼만 인덱스를 걸어야 한다면, 해당 컬럼은 **카디널리티(Cardinality)가 가장 높은 것**을 잡아야 한다는 점입니다.
2.  가급적 로직을 DB상에서 처리하지 않고 WEB Applicaition 상에서 구현한다.
3.  칼럼의 데이터길이를 최대한 작게 보수적으로 설정한다.
4.  Insert 보다는 Select 횟수가 많기 때문에 Select에 보수적인 로직을 구성한다.
5.  WHERE 절에서 검색 대상 칼럼이 인덱스여야 한다.
6.  AND절 검색시 하나의 칼럼에만 인덱스 조회가 된다.
7.  OR절 검색은 무조건 Full SCAN 된다.
8.  LIMIT를 사용할때는 무조건 LIMIT가 되는 기준을 정해준다.
9.  LIKE % 보다는 FULLTEXT를 활용한다.



#### MongdoDB

1. 인덱스는 비용이다 
   * 먼저 인덱스는 두 번 탐색하도록 강요한다. 
   * 인덱스 리스트, 그다음 컬렉션 순으로 탐색하기 때문이며, 관련 읽기 비용이 들게 된다.
   * 컬렉션이 수정되었을
2. 항상 테스팅하라
   * explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을하면 시간측정을 해야 한다
     * MySQL도  EXPLIAN 키워드가 있다.
3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티순이다.
   * 어떠한 값과 같음을 비교하는 ==이나 equals이라는 쿼리가 있다면 제일 먼저 인덱스로 설정
   * 정렬에 쓰느 ㄴ필드라면 그 다음 인덱스로 설정
   * 다중 값을 출력해야 하는 쿼리 자체가 > < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 설정한다
   * 유니크한 값의 정도를 카디널리티라고 한다. 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다.
   * age와 email중 카디널리티가 더 높은것은 email이다 즉 email에 대한 인덱스를 먼저 생성해야 한다

