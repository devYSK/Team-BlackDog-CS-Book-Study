# 조인의 종류

조인(join)이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말한다.  
MySQL에서는 JOIN 이라는 쿼리로, MongoDB에서는 lookup이라는 쿼리로 이를 처리할 수 있다.



* 참고로 MongdoDB를 사용할 때 lookup은 되도록 사용하지 말아야 한다. MongdoDB는 조인 연산에 대해 RDBMS 보다 성능이 떨어진다고 여러 테스트 결과에서 알려져 있다.
  * 관계형 데이터베이스는 조인을 하기 위해 사용한다



- 내부 조인(inner join): 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
- 왼쪽 조인(left outer join): 왼쪽 테이블의 모든 행이 결과 테이블에 표기
- 오른쪽 조인(right outer join): 오른쪽 테이블의 모든 행이 결과 테이블에 표기
- 합집합 조인(full outer join): 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

<img src="https://blog.kakaocdn.net/dn/b4E4qd/btrR2If8UJj/ZWovtcmKYrnL4nvITbzalK/img.png" width=650 hegiht=450>





## 조인의 종류들

여기서 왼쪽 테이블은 A라고 칭하고 오른쪽 테이블은 B로 칭한다.   


테이블.key는 조인 대상이 되는 컬럼이며, 보통 인덱스나 key가 조인 조건으로 많이 사용한다.   


### 내부 조인 (inner, equ)

내부 조인(inner join)은 두 테이블 간에 교집합을 나타낸다

```mysql
SELECT * FROM TableA A
INNER JOIN TableB B 
ON A.key = B.key
```

A와 B 테이블을 조인하는데, 이 때 A.key와 B.key가 같은 조건만 조인한다.



---

### 왼쪽 조인 (left join, left outer join)

조인 대상이 되는 두 테이블 중 왼쪽 테이블을 기준으로 조인하는것.  

테이블 A, B 가 있을 때 A를 기준으로 LEFT 조인하면, 조인 결과에 A테이블은 다 보여주지만, B에 일치하는 항목이 없는 경우 NULL값을 표기한다.  


```mysql
SELECT * FROM TableA A
LEFT JOIN TableB B 
ON A.key = B.key
```





---


### 오른쪽 조인(right join, right outer join)

조인 대상이 되는 두 테이블 중 오른쪽 테이블을 기준으로 조인한다.

테이블 A, B 가 있을 때 B를 기준으로 RIGHT 조인하면 조인 결과에 B 테이블은 다 보여주지만 A에 일치하는 항목이 없는 경우 NULL값을 표기한다.

```mysql
SELECT * FROM TableA A
RIGHT JOIN TableB B
on A.key = B.key
```





---

### 합집합 조인 (완전 외부 조인, FULL OUTER JOIN)

양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성한다.  A와 B의 합집합을 얻게 된다. 

B에는 있는데 A에 없는 컬럼은 A에서는 해당 부분이 null 이 되고,  


A에는 있는데 B에 없는 컬럼은 B에서는 해당 부분이 null 이 된다.      


```mysql
SELECT * FROM TableA A
FULL OUTER JOIN TableB B
ON A.key = B.key
```



## 조인의 원리

조인의 종류는 다음과 같은 원리를 기반으로 조인한다.  
중첩 루프 조인, 정렬 병합조인, 해시 조인




### 중첩 루프 조인 (NLJ, Neted Loop Join)

중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법이며, 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않는다. 

* 예를 들어 t1, t2 테이블을 조인한다 했을 떄 첫 번째 테이블에서 행을 한번에 하나씩 읽고 그다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값을 반환한다

```python
//sudocode

for each row in t1 matching reference key {
  for each row in t2 matcinh reference key {
    if row satisfies join conditions, send to client
  }
}
```

중첩 루프 조인에서 발전한 방법은 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 블록 중첩 루프 조인(BNL, Block Nested Loop) 라는 방식도 있다.

  


### 정렬 병합 조인

각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인.  
조인할때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <,> 등 범위 비교 연산자가 있을 때 사용한다

​    


### 해시 조인

해시 테이블을 기반으로 조인하는 방법.  
두 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적이다 ( 메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용이 발생되니까. )  

해시 조인은 == 조건에만 쓰이며,  두 개의 테이블을 조인한다고 했을 때 바이트상 더 작은테이블을 해시테이블로 만들어서 조인

  


#### 해시 조인 빌드 단계

- 해시조인은 **빌드 단계(Build-phase)**와 **프로브 단계(probe-phase)**로 나눌 수 있다.
  1. **빌드 단계** - 메모리 내 해시 테이블을 빌드하는 단계 
     - 조인 대상 테이블 중 레코드가 적어서 해시 테이블로 만들기 용이한 테이블을 골라서 메모리에 **해시 테이블을 생성(빌드)**하는 작업
     - 빌드 단계에서 해시테이블을 만들기 위해 사용되는 원본 테이블을 **빌드 테이블**이라 한다.
     - 조인 대상 두 테이블 중 더 작은 테이블을 기반으로 테이블을 빌드한다.
     - 조인에 사용되는 필드가 해시 테이블의 키로 사용된다.
  2. **프로브 단계**
     - 빌드테이블이 아닌 나머지 테이블의 레코드를 읽어 **해시 테이블과 일치하는 레코드를 찾는** 과정
     - 빌드 테이블이 아닌 나머지 테이블을 **프로브 테이블**이라고 한다.
     - 각 레코드에서 조인 대상이 되는 컬럼에 일치하는 레코드를 찾아서 결괏값으로 반환한다.



이 단계를 통해서 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋다.

해시테이블을 저장하는 메모리 공간은 조인 버퍼이다. `join_buffer_size` 변수로 런타임에 크기를 제어할 수 있는데  조인 버퍼 공간이 부족한 경우는 빌드, 프로브 테이블을 적합한 크기의 청크로 분리하여 처리한다. 조인 버퍼 공간이 부족하면 청크로 분리해 내부적으로 알아서 처리된다.



