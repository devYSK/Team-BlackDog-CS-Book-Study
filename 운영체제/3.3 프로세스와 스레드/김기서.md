# 3.3 프로세스와 스레드

**프로세스**

- 컴퓨터에서 실행되고 있는 **프로그램**
- CPU 스케줄링의 대상이 되는 작업(task)

**스레드**

- **프로세스 내** 작업의 흐름

![image](https://user-images.githubusercontent.com/81108344/206996063-db992477-5d5f-43c5-a6ae-2dc9afa311df.png)
프로그램이 메모리(RAM)에 올라가면 **프로세스**가 되는 **인스턴스화**가 일어난다.

→ 이후 운영체제의 CPU 스케줄러에 따라 CPU가 프로세스를 실행한다.

- 프로그램이란 0과 1로 된, 컴퓨터에게 어떤 동작을 실행하라는 **명령어**들의 집합이다. 이 프로그램이란 것을 실행시키게 되면 프로그램이라 불리는 명령어들이 **메인 메모리**(RAM 램)에 배치된다. 이 상태를 **프로세스**라고 부른다.
- 이 배치된 명령어들을 하나씩 순서대로, 혹은 지정된 주소에 있는 명령어들을 읽어와서 **CPU**에서 **계산 및 처리**를 하게 되고 그 명령어대로 CPU가 다른 컴퓨터 **자원들의 동작, 수행을 명령**한다. 그리고 이 0과 1로 이루어진 명령어 들을 **기계어**라고 한다.

# 3.3.1 프로세스와 컴파일 과정

**컴파일 언어의 컴파일 과정**
![image](https://user-images.githubusercontent.com/81108344/206996071-80a9c858-5a96-45ca-bee4-c803e9464fc0.png)

### 1. 전처리

- 소스 코드의 주석을 제거하고 #include 등의 헤더 파일을 병합하여 매크로를 치환한다.

### 2. 컴파일러

- 오류 처리, 코드 최적화 작업을 하며 **어셈블리어**로 변환한다.

### 3. 어셈블러

- 어셈블리어를 **목적 코드(object code)**로 변환한다.
- 확장자는 운영체제마다 다르며 각 운영체제에 맞는 확장자 파일이 생성된다.

⇒ 컴퓨터는 오직 기계어(0과 1로 이루어진)만 이해할 수 있기 때문에 **어셈블리어를** 0과 1의 집합인     기계어로 바꿔주는 역할을 하는 프로그램이 바로 이 **어셈블러**다.

### 4. 링커

- 프로그램 내에 있는 라이브러리 함수 또는 다른 파일과 목적 코드를 결합해 실행 파일을 만든다.
- 실행 파일은 .exe 또는 .out이라는 확장자를 갖는다.

⇒ 어셈블러가 생성한 목적 파일들을 결합하여 하나의 실행 파일로 만드는 작업을 해준다.

![image](https://user-images.githubusercontent.com/81108344/206996077-03ddf942-38f5-4fe9-9124-0b5693f83a00.png)
**정적 라이브러리와 동적 라이브러리**

정적 라이브러리: 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 **실행 파일**에 넣는 방식

→ 시스템 환경 등 외부 의존도가 낮으나 코드 중복, 메모리 효율성 등의 단점도 존재한다.

동적 라이브러리: 프로그램 실행 시 필요할 때만 **DLL** 이라는 함수 정보를 통해 참조하는 방식

→ 메모리 효율성은 높으나 외부 의존도가 높아진다는 단점이 존재한다.

**DLL(Dynamic Link Library)**이란?

- 동적 링크라고 하며 실행 파일에서 해당 라이브러리의 기능을 사용 시에만, 라이브러리 파일을 참조하여(혹은 다운로드받아) 기능을 호출한다.
- 정적 링크와는 다르게 컴파일 시점에 실행 파일에 함수를 복사하지 않고, 함수의 위치정보만 갖고 그 함수를 호출할 수 있게 한다.

# 3.3.2 프로세스의 상태

### 생성 상태

- 프로세스가 생성된 상태
- `PCB`가 할당된다.
- fork(), exec() 함수를 통해 생성된다.

  **fork()**

    - 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하지 않는 함수
    - fork() 시스템 호출은 새로운 프로세스를 위한 메모리를 할당한다. 그리고 fork( ) 를 호출한 프로세스를 새로운 공간으로 모두 복사한다.
    - 이후 원래 프로세스는 원래 프로세스대로 실행되고, fork를 이용해서 생성된 프로세스도 fork( ) 시스템 콜이 수행된 라인의 다음 라인부터 실행된다.

  **exec()**

    - 새롭게 프로세스를 생성하는 함수
    - exec 시스템 콜은 fork( ) 처럼 새로운 프로세스를 위한 메모리를 할당하지 않고, exec( )를 호출한 프로세스의 메모리에 새로운 프로세스의 코드를 덮어씌워 버린다.
    - 따라서, exec를 호출한 프로세스가 아닌 exec에 의해 호출된 프로세스만 메모리에 남게 된다.

```java
Process proc = Runtime.getRuntime().exec("java -jar A.jar");
```

### 대기 상태

- 메모리 공간이 충분하면 메모리를 할당받고 아니면 그대로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

### 대기 중단 상태

- 메모리 부족으로 일시 중단된 상태

### 실행 상태

- CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태

### 중단 상태

- 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
- I/O 디바이스에 의한 **인터럽트**로 이런 현상이 많이 발생한다.
- ex) 프린트 인쇄 버튼을 눌렀을 때 프로세스가 잠깐 멈춘 듯할 때

### 일시 중단 상태

- 중단 상태에서 프로세스가 실행되려고 했으나 메모리 부족으로 일시 중단된 상태

### 종료 상태

- 메모리와 CPU 소유권을 모두 반납하고 가는 상태
- 부모 프로세스가 강제로 종료시키는 **비자발적 종료**

# 3.3.3 프로세스의 메모리 구조

- 운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당하게 된다.



![image](https://user-images.githubusercontent.com/81108344/206996088-58360a5c-e36b-4566-8057-54c26039bceb.png)
### 스택

- **지역변수, 매개변수, 함수**가 저장되며 **컴파일** 시에 크기가 결정되는 **동적**인 특징을 갖는다.
- 함수 호출 시 할당되고 함수 반환 시 소멸되며 **잠시 사용되었다가 사라지는 데이터**를 저장하는 영역이다.
- 스택 영역은 동적으로 크기가 늘어날 수 있으므로 힙 영역과 겹치지 않기 위해 힙과 스택 사이에 공간을 비워 놓는다.

### 힙

- 동적 할당할 때 사용되며 **런타임** 시 크기가 결정된다.
- ex) 벡터와 같은 동적 배열은 힙에 할당된다.
- 자바에서는 객체가 heap영역에 생성되고 GC에 의해 정리된다.
- stack에서 person 변수를 할당하면 person이 가리키는 heap 영역의 임의의 공간부터 원하는 크기만큼 할당해 사용하게 된다.

### 데이터 영역

- 전역변수, 정적변수가 저장된다.
- **BSS 영역**과 **Data 영역**으로 나뉘며, BSS 영역은 초기화 되지 않은 변수들이 0으로 초기화되어 저장된다. 초기화 된 전역변수는 Data 영역에 저장된다.

### 코드 영역

- 프로그램에 내장된 **소스코드**가 들어가는 영역
- CPU는 이 영역에서 명령어를 하나씩 가져와 처리한다.
- 수정 불가능한 기계어로 저장되어있다.

## 3.3.4 PCB

### PCB(Process Control Block)란

- 운영체제에서 프로세스에 대한 **메타데이터**를 저장한 데이터
- 프로세스가 생성되면 운영체제는 해당 PCB를 생성한다.
- 프로세스의 중요 정보가 포함되므로 커널 스택의 가장 앞부분에서 관리된다.

**PCB의 구조**

- PCB는 다음과 같은 정보로 이루어져 있다.
    - 프로세스 스케줄링 상태: 준비, 일시중단 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
    - 프로세스 ID
    - 프로세스 권한: 컴퓨터 자원, I/O 디바이스에 대한 권한 정보
    - CPU 레지스터: 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
    - CPU 스케줄링 정보: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
    - 계정 정보: 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
    - I/O 상태 정보: 프로세스에 할당된 I/O 디바이스 목록

## 컨텍스트 스위칭(context switching)

- PCB를 교환하는 과정
- 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다.

**컨텍스트란?**

CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들이다.

컨텍스트는 프로세스의 **PCB(Process Control Block)**에 저장된다.

CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업을 **컨텍스트 스위칭**이라 한다.

### 비용

![image](https://user-images.githubusercontent.com/81108344/206996097-d02d368a-6d14-4ba7-810c-c5b852146811.png)

### 유휴 시간

- 위 그림을 보면 프로세스 A가 실행 중인 상태에서 유휴 상태가 될 때 프로세스 B가 곧바로 실행되지 못한다.
- 그 이유는 프로세스 A의 상태를 PCB에 저장하고 프로세스 B 상태를 PCB에서 가져와야 하기 때문이다.
- 그런데, 이 과정에서 PCB를 저장하고 가져올 때 CPU는 아무런 일도 하지 못하게 된다.
  이처럼 아무런 일도 하지 못하게 되는 상황이 잦을수록 성능 저하로 이어진다.

### 캐시 미스

- 캐시에는 현재 실행중인 프로세스의 data가 들어있다.
- 컨텍스트 스위칭이 발생하면 이 정보들이 쓸모없어질 확률이 높으므로 캐시를 비워버린다.
- 컨텍스트 스위칭 직후에는 캐시가 비어있으므로 계속해서 캐시미스가 발생한다.
- 메모리로 가서 캐시로 데이터를 올리고 CPU로 가져오는 횟수(메모리 접근 횟수)가 증가하여 오버헤드가 커진다.

### 스레드에서의 컨텍스트 스위칭

- 스택 영역을 제외한 모든 메모리를 공유하므로 스레드 컨텍스트 스위칭이 비용과 시간 둘다 적게 소모된다.
- 멀티 쓰레드 > 멀티 프로세스 ?