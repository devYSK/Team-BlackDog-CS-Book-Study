### 3.5 멀티프로세싱

![https://blog.kakaocdn.net/dn/NsBOQ/btq84u6rySg/supHkC9UXJVYuD0XZ0mfJ1/img.jpg](https://blog.kakaocdn.net/dn/NsBOQ/btq84u6rySg/supHkC9UXJVYuD0XZ0mfJ1/img.jpg)

여러개의 ‘프로세스’, 즉 멀티 프로세스를 통해 동시에 두가지 이상의 일을 수행할 수 있는 것을 말한다.

하나 이상의 일을 병렬처리할 수 있으며, 특정 프로세스의 메모리, 프로세스 중 일부에 문제가 발생되더라도 다른 프로세스를 이용해서 처리 할수 있어 신뢰성이 높다.

**웹브라우저**

웹 브라우저가 어떻게 작동해야 한다는 표준은 없다.

1. 한 프로세스가 스레드를 왕창 들고 있는 아키텍처
2. 스레드를 몇 개 가지고 있는 다수의 프로세스들이 IPC를 통해 통신하는 아키텍처

![https://blog.kakaocdn.net/dn/n98qe/btraixf29Ki/0kk3Vjrjs8DvwUmMtkhRh0/img.png](https://blog.kakaocdn.net/dn/n98qe/btraixf29Ki/0kk3Vjrjs8DvwUmMtkhRh0/img.png)

크롬 브라우저는 여러 개의 프로세스로 이루어진 프로그램이다.싱글 프로세스였다면 브라우저에서 탭을 여러 개 킨 상태에서 하나의 잘못된 페이지에 접근할 경우 혹은 렌더링에 문제가 발생했을 때 브라우저 전체가 종료될 수 있다. 이 떄 정상적인 동작을 수행한 탭들은 억울하게 잃어버리게 된다. 실제로 이런 일이 종종 발생했기 때문에 멀티 프로세스로 구성이 되었다고 한다.

- 브라우저 프로세스 : 주소 표기줄, 북마크 막대, 뒤로가기 버튼 등을 담당하며 네트워크 요청이나 파일 접근 같은 권한을 담당합니다.
- 렌더러 프로세스 : 웹 사이트가 ‘보이는’ 부분의 모든 것을 제어합니다.
- 플러그인 프로세스 : 웹 사이트에서 사용하는 플러그인을 제어합니다.
- GPU 프로세스 : GPU를 이용해서 화면을 그리는 부분을 제어합니다.

![https://blog.kakaocdn.net/dn/cvrlyj/btracZSoVYo/nx0SxV6kczXRMrsxoRpcYk/img.png](https://blog.kakaocdn.net/dn/cvrlyj/btracZSoVYo/nx0SxV6kczXRMrsxoRpcYk/img.png)

**IPC(Inter Process Communication)**

프로세스 간 통신(Inter-Process Communication, IPC)이란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.

클라이언트와 서버가 데이터를 주고 받는것도 IPC의 예이다.

IPC의 종류로는 `공유메모리`, `파일`, `소켓`, `익명 파이프`, `명명 파이프`, `메세지 큐`가 있다.

이들은 모두 메모리가 완전히 공유되는 스레드 보다 속도가 떨어진다.

- 공유메모리

  : 여러 프로세스에 동일한 메모리 블럭에 대한 접근 권한이 부여되어 프로세스가 서로 통신할 수 있도록 공유 버퍼를 생성하는 것을 말한다.

  : 기본적으로 각 프로세스의 메모리를 다른 프로세스가 접근할 수 없지만 공유 메모리를 통해 여러 프로세스가 하나의 메모리에 접근할 수 있다.

  : 어떤 매개체를 통해 데이터를 주고 받는 것이 아닌 메모리 자체를 공유하기 때문에 불필요한 데이터 복사 오버헤드가 발생하지 않아 가장 빠르며 같은 메모리 영역을 공유하기때문에 동기화가 필요없다.

  : 하드웨어 관점에서 공유 메모리는 CPU가 접근할 수 있는 메모리인 RAM을 가르키기도 한다.

- 파일

  : 파일 디스크에 저장된 데이터 또는 파일 서버에서 제공하는 데이터. 이를 기반으로 프로세스 간 통신을 한다.

- 소켓

  : 동일한 컴퓨터의 다른 프로세스나 네트워크 인터페이스를 통한 다른 컴퓨터의 프로세스에 전송하는 데이터를 의미하며 TCP/UDP 방식 있다.

  : 네트워크 소켓은 컴퓨터 네트워크를 경유하는 프로세스 간 통신의 종착점이다.

- 파이프
    1. 익명 파이프

       : 프로세스간에 FIFO방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고 받으며, 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동하는 방식을 말한다.

       : 부모, 자식 프로세스 간에만 사용할 수 있으며, 다른 네트워크 상에서는 상용이 불가능하다.


    1. 명명 파이프

       : 파이스 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 단방향, 또는 이중파이프를 말한다.

       : 하나의 파이프를 인스턴스 방식으로도 사용 가능하고 여러개의 파이프를 동시에 사용할 수 있다.

       : 같은 컴퓨터의 프로세스끼리 또는 다른 네트위크 상의 컴퓨터와도 통신 할 수 있다.


- 메세지 큐

  : 메세지를 큐 데이터 구조 형태로 관리하는 것.

  : 커널에서 전역적으로 관리 되며 다른 IPC방식에 비해 간단하게 사용할 수 있다.

  : 공유 메모리를 통해 IPC를 구현할때, 쓰기 읽기 빈도가 높으면 동기화 때문에 기능 구현이 매우 복잡해 지는데, 이를 대안으로 메세지 큐를 사용하기도 한다.

  ![https://velog.velcdn.com/images%2Fchappi%2Fpost%2F9af3f4ca-c178-4866-84bd-9c63dcb40dc9%2F2.png](https://velog.velcdn.com/images%2Fchappi%2Fpost%2F9af3f4ca-c178-4866-84bd-9c63dcb40dc9%2F2.png)


### 3.6 스레드와 멀티 스레딩

**********쓰레드**********

“프로세스 내에서 실행되는 여러 흐름의 단위”

프로세스가 할당받은 자원을 이용하는 실행의 단위

![https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)

스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다. 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.

반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.

**멀티스레딩**

프로세스 내 작업을 여러 개의 스레드, 멀티 스레드로 처리하는 기법이며 스레드끼리 서로 자원을 공유하기 때문에 효율성이 높다.

: 예를 들어 웹 요청이 들어왔을때, 새 프로세스를 처리하는 것 대신 스레드를 사용하면 훨씬 적은 리소스를 소비하며, 한 스레드가 중단(Blocked) 되어도 다른 스레드는 실행(running) 상태 일수 있기때문에 중단되지 않은 빠른 처리가 가능하다.

: 동시성에도 큰 장점이 있다. → 서로 독립적인 작업들을 작은 단위로 나누고 동시에 실행되는 것처럼 보여주는 것.

: 웹 브라우저의 렌더러 프로세스를 예로 들수있다. (메인 스레드, 워커 스레드, 컴포지터 스레드, 레스터 스레드가 존재한다.)

### 3.7 공유자원과 임계영역

************************공유자원************************

시스템 안에 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 파일, 데이터 등의 자원이나 변수를 의미한다.

: 공유 자원을 두개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁상태(race condition)이라고 한다.

**임계영역(critical section)**

둘 이상의 프로세스(혹은 스레드)가 공유자원에 접근할때 순서등의 이유로 결과가 달라지는 코드 영역을 말한다.

: 임계 영역을 해결하는 방법은 크게 뮤텍스, 세마포어, 모니터가 있다. 세방식 모두 lock 메커니즘을 토대로 한다.

: 세가지 방법 모두 상호 배제, 한정 대기, 융통성이란는 조건을 만족한다.

상호 배제 → 한 프로세스가 임계 영역에 들어갔을때 다른 프로세스가 들어갈 수 없다.

한정 대기 → 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안된다.

융통성 → 한 프로세스가 다른 프로세스의 일을 방해해서는 안된다.

- 뮤텍스

  ![https://blog.kakaocdn.net/dn/cvk7nh/btrjvSw2BoX/Zfh0o0VsZrMmAOi6PxLvg0/img.png](https://blog.kakaocdn.net/dn/cvk7nh/btrjvSw2BoX/Zfh0o0VsZrMmAOi6PxLvg0/img.png)

  프로세스나 스레드가 공유자원을 lock()을 통해 잠금을 설정하고 사용 후에는 unlock()을 통해 잠금해제하는 객체.

  : 다른 프로세스나 스레다가 잠긴 코드 영역에 접근할 수 없다.

  : 잠금 또는 잠금해제 상태만을 가진다.

  : 한 스레드가 임계 영역에 들어가기 위해 lock을 하고 나올때 unlock을 한다.


- 세마포어

  ![https://blog.kakaocdn.net/dn/cYZOiu/btrjvrzaimS/QtooHYav5Sj1JpT9yTtb1K/img.png](https://blog.kakaocdn.net/dn/cYZOiu/btrjvrzaimS/QtooHYav5Sj1JpT9yTtb1K/img.png)

  일반화된 뮤텍스.

  : 간단한 정수 값과 두가지의 함수 wait, signal로 공유 자원에 대한 접근을 처리한다.

  wait → 자신의 차례가 올때까지 기다리는 함수

  signal → 다음 프로세스로 순서를 넘겨주는 함수.

  : wait이 먼저 호출되어 임계영역에 들어갈 수 있는 지, 먼저 실행되어야 하는 프로세스가 실행되는지 확인한다. 조건에 만족하면 wait을 빠져나와 임계영역에 들어간다. 이후 임계영역을 빠져나왔음을 signal을 호출하여 알린다.

  : 프로세스가 자원을 점유하고 반납하는 뮤텍스와 달리 세마포어는 자원의 상태를 나타내는 일종의 ‘변수’로서 소유개념이 아니다.

    - 바이너리 세마포어 : 0, 1 두가지 값만 가질 수 있는 세마포어. 구현의 유사성으로 인해 뮤텍스를 바이너리 세마포어라고 하기도 하지만, 엄밀히 말하면 뮤텍스는 잠금을 기반으로 상호 배제가 일어나는 잠금 매커닌즘, 바이너리 세마포어는 신호를 기반으로 상호배제가 일어나는 ‘신호 매커니즘이다.
    - 카운팅 세마포어 : 여러 개의 값을 가질 수 있으며, 여러 자원에 대한 접근을 제어하는데 사용된다.

- 모니터

  둘 이상의 프로세스(스레드)가 공유자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공합니다.

  모니터 큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리한다.

  : 뮤텍스나 세마포어보다 구현이 쉬우며 모니터에서 상호배제는 자동인 반면 세마포어에서는 상호 배제를 명시적으로 구현행해야 하는 차이점이 있다.


### 3.8 교착상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e2984b84-cf70-4f07-b4cd-6326f9e0dd63/Untitled.png)

두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

**발생조건**

1. 상호 배제 : 한 프로세스가 자원을 독점하고 있으면 다른 프로세스들은 접근이 불가능하다.
2. 점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청한 상태
3. 비선점 : 다른 프로세스의 자원을 강제적으로 가져올 수 없다.
4. 환형 대기 : 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황

**해결방안**

1. 예방

   교착 상태 발생 조건 중 하나 이상을 제거함으로서 해결한다.

    - 상호 배제 조건 제거

      → 모든 자원의 공유를 허용함.

    - 점유 대기 조건 제거

      → 필요한 모든 자원을 할당함 (자원 낭비 발생)

      → 자원을 점유하고 있지 않을 때만 다른 자원을 요청할 수 있도록 함.(기아 상태 가능성)

    - 비선점 조건 제거

      → 이미 실행 중인 작업의 상태를 잃을 수 있다. 작업의 상태를 저장, 복구할 수 있을 때만 가능함.

    - 순환대기 조건 제거

      → 자원에 고유 번호를 매기고 번호 순서대로 특정 방향으로만 자원을 요구하도록 함.(자원 낭비 발생)

2. 회피

   교착상태가 발생하기 전 교착상태를 예측하고 회피하는 방법이다.

    - 은행원 알고리즘

      → 자원할당 허용 여부를 결정하기 전에 데드락이 빠질 가능성이 있는지 없는지 운영체제가 검사하고 빠질 가능성이 없을 경우에만 자원을 할당함으로써 문제 발생을 피하는 방법


     회피할 수 있는 조건을 달성하기 어렵고 자원을 요청할 때마다 회피 알고리즘을 사용하면 오버헤드가 크기 때문에 현실성 없는 방법이다.

3. 탐지, 복구
    - 탐지

      : 교착 상태를 허용하되 탐지 알고리즘을 실행하여 교착상태를 탐지하면 복구하는 방법이다.

      : 탐지 알고리즘을 너무 자주 호출할 경우 오버헤드가 커지기 때문에 적절한 시점과 주기에 호출할 필요가 있다.

    - 복구

      : 교착 상태가 제거 될때까지 프로세스를 하난씩 중지하거나, 점유 자원을 다른 프로세스에게 할당하는 방식


4. 무시

   교착상태를 무시하고 특별한 조치를 취하지 않는 방법.

   교착상태를 주기적으로 탐지하거나 예방하기 위해서 필요한 오버헤드보다 교착상태를 무시할 때 더 이득이 크기 때문에 Window, Linux등 운영체제에서 선택하는 방식이다.


**기아상태**

특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태를 말한다. 프로세스의 무한정 기다림