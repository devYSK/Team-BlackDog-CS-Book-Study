### 프로세스

메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)

운영체제로부터 시스템 자원을 할당받는 작업의 단위

즉, 동적인 개념으로는 실행된 프로그램을 의미한다.


시스템 자원이란?

→ CPU 시간
→ 운영되기 위해 필요한 주소 공간
→ Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역

![https://gmlwjd9405.github.io/images/os-process-and-thread/process.png](https://gmlwjd9405.github.io/images/os-process-and-thread/process.png)



### 쓰레드

“프로세스 내에서 실행되는 여러 흐름의 단위”

프로세스가 할당받은 자원을 이용하는 실행의 단위

![https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)

스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다. 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.

반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.



**java의 스레드**

일반 스레드와 거의 차이가 없으며, JVM가 운영체제의 역할을 한다.

자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.

자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다. 

즉, 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일 뿐이다.


---


## 프로세스와 컴파일 과정


**인터프리티 언어 vs 컴파일 언어**

인터프리터 언어는 원시코드(프로그래머가 작성한 소스코드)를 기계어로 변환하는 과정없이 한줄 한줄 해석하여 바로 명령어를 실행하는 언어. R, Python, Ruby와 같은 언어들이 대표적인 인터프리터 언어이다.

인터프리터가 직접 한 줄씩 읽고 따로 기계어로 변환하지 않기 때문에 빌드 시간이 없습니다. Runtime 상황에서는 한 줄씩 실시간으로 읽어서 실행하기 때문에 컴파일 언어에 비해 속도가 느립니다.

실행속도는 느리지만 코드 변경시 빌드 과정없이 바로 실행이 가능하다는 장점이 있습니다.

컴파일 언어는 원시코드(프로그래머가 작성한 소스코드)를 모두 기계어로 변환한 후에 기계(JVM 같은 가상 머신)에 넣고 기계어 코드를 실행합니다. 소스코드를 기계어로 번역하는 빌드 과정에서는 인터프리터 언어에 비해 시간이 소요됩니다. 하지만 런타임 상황에서는 이미 기계어로 모든 소스코드가 변환되어 있기 때문에 빠르게 실행할 수 있습니다.



**컴파일 과정 (C언어 기준)**

컴파일 : 프로그램 코드를 컴퓨터가 이해할 수 있는 언어로 변환하는 작업

![https://velog.velcdn.com/images/narangke3/post/a9daf66d-aab5-41a7-b8c0-268b535ea7a2/image.png](https://velog.velcdn.com/images/narangke3/post/a9daf66d-aab5-41a7-b8c0-268b535ea7a2/image.png)

1. 전처리기
    
    .i 파일 생성. 헤더파일 삽입(#include), 매크로 치환(#define, #ifdef) 작업을 수행한다.
    
2. 컴파일러
    
    전처리가 끝난 **.i** 파일을 컴파일 하면 **.s 어셈블리 코드**로 이루어진 파일이 만들어진다.
    
3. 어셈블러
    
    컴파일이 끝난 어셈블리 코드는 어셈블러에 의해 기계어로 변경된다.
    
    어셈블러에 의해 생성되는 목적코드 .o는 명령어와 데이터가 들어있는 바이너리 포맷 구조를 갖는다.
    
    목적 코드 → 다음단계에서 링커가 여러개의 바이너리 파일을 하나의 실행 파일로 묶기 위해서 각 바이너리의 정보를 효과적으로 파악하기 위해서(명렁어와 데이터의 범위 등) 일정한 규칙을 갖게 형식화 해놓은 것
    
4. 링커
    
    목적 파일을 다른 목적파일 + 이미 만들어진 라이브러리들을 결합시킨다. 
    
    이 단계를 거치면 실행파일(.exe)이 완성된다.
    

이 실행파일을 실행하면 운영체제의 로더(Loder)가 메모리에 프로그램을 적재하게되며 프로그램이 메모리에 로드된 상태를우리는 "프로세스(Process)가 발생했다"라고 한다.



## 프로세스 상태

각각의 프로세스들은 매 시점마다 5가지 상태 중 하나의 상태를 가진다

[https://t1.daumcdn.net/cfile/tistory/99366D365D024C3B39?original](https://t1.daumcdn.net/cfile/tistory/99366D365D024C3B39?original)

- Run (실행)
    
    : 프로세스가 CPU를 차지하여 실행 중인 상태. 
    
    : 수행이 완료되기 전에 프로세스에게 주어진 할당 시간이 종료(timer run out)되면 프로세스는 Ready 상태로 전이
    
    : 실행중인 프로세스에 I/O 처리가 필요하면 Wait 상태로 전이
    
- Ready (준비상태)
    
    : 프로세스가 CPU를 사용하기 위해 기다리는 상태.
    
- Wait,Block (대기상태)
    
    : I/O 요구가 발생되어 실행중인 프로세스가 중단되고 I/O 처리가 완료될 때까지 대기하는 상태. 작업이 완료되면 디스크 컨트롤러가 CPU에게 일이 끝났음을 알리고(인터럽트) 해당 프로세스는 준비큐에 넣어준다.
    
- Suspend (대기중단)
    
    : 보류(대기) 상태에서 운영체제에 의해 일시적으로 벗어나는 상태입니다. 필요한 자원은 모두 얻었지만, 주기억장치에 적재되지 못한 상태.
    
- terminated (완료)
    
    프로세스 실행이 완료되어 자원을 반납하나 상태
    



## 프로세스의 메모리 구조

![http://www.tcpschool.com/lectures/img_c_memory_structure.png](http://www.tcpschool.com/lectures/img_c_memory_structure.png)

- 코드(code) 영역

메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

- 데이터(data) 영역

메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.

데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다. 

Data 영역 : 초기값을 설정한 전역 변수와 정적 변수를 위한 영역

BSS 영역 : 초기값을 설정하지 않은 전역 변수와 정적 변수를 위한 영역으로 0으로 자동 초기화해 줘요.

- 스택(stack) 영역

메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.  수행 흐름을 위한 데이터를 임시로 저장하는 영역.

스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.

스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.

이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.

스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.

- 힙(heap) 영역

힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.

힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

(Reference Type 의 데이터가 저장되는 공간)



## PCB


**Process Management**

> CPU가 프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것을 말함
> 

이때, CPU는 각 프로세스들이 누군지 알아야 관리가 가능함

프로세스들의 특징을 갖고있는 것이 바로 `Process Metadata`

- Process Metadata
    - Process ID
    - Process State
    - Process Priority
    - CPU Registers
    - Owner
    - CPU Usage
    - Memeory Usage

이 메타데이터는 프로세스가 생성되면 `PCB(Process Control Block)`이라는 곳에 저장됨



**PCB(Process Control Block)**

> 프로세스 메타데이터들을 저장해 놓는 곳, 한 PCB 안에는 한 프로세스의 정보가 담김
> 

![https://images.velog.io/images/hoyun7443/post/2efb3210-70cb-497a-8acf-5b8b651b7b14/image.png](https://images.velog.io/images/hoyun7443/post/2efb3210-70cb-497a-8acf-5b8b651b7b14/image.png)

프로그램 실행 → 프로세스 생성 → 프로세스 주소 공간에 (코드, 데이터, 스택) 생성
→ 이 프로세스의 메타데이터들이 PCB에 저장


- PCB가 필요한 이유

CPU에서는 프로세스의 상태에 따라 교체작업이 이루어진다. (interrupt가 발생해서 할당받은 프로세스가 waiting 상태가 되고 다른 프로세스를 running으로 바꿔 올릴 때)

이때, **앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해두는 것**이다.


- PCB 관리

Linked List 방식으로 관리함

PCB List Head에 PCB들이 생성될 때마다 붙게 된다. 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이함.

즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료시 제거됨



**Context Switching**

> CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정
> 

PCB를 교환하는 과정. 

보통 인터럽트가 발생하거나, 실행 중인 CPU 사용 허가시간을 모두 소모하거나, 입출력을 위해 대기해야 하는 경우에 Context Switching이 발생. (프로세스가 Ready → Running, Running → Ready, Running → Waiting처럼 상태 변경 시 발생)

컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 어떠한 시점에서 실행되고 있는 프로세스는 단 한개이며, 많은 프로세스가 동시에 구동되는 것처럼 보인느 것은 다른 프로세스왕의 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문이다.


- 스레드에서의  Context Switching
    
    스레든는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭의 경우 비용이 적고 시간도 더 적게 걸린다.
    

- Context Switching 비용
    
    캐시미스 : 스위칭이 일어날때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘 못된 주소변환이 생기므로 캐시클리어 과정을 겪게 되기때문에 캐시미스가 발생한다.
    
    프로세스를 수행하다가 입출력 이벤트가 발생해서 대기 상태로 전환시킴. 이때, CPU를 그냥 놀게 놔두는 것보다 다른 프로세스를 수행시키는 것이 효율적이기 때문에 CPU에 계속 수행되도록 비용을 감수하는 상황
    



reference.

[https://kosaf04pyh.tistory.com/190](https://kosaf04pyh.tistory.com/190)
