## 프로세스란?

프로세스란 실행 중인 프로그램을 말한다.

작업이라는 단어와 같은 의미로 운영체제에서 사용된다.

프로그램과 프로세스는 다르다.

프로그램은 명령어들이 저장된 파일이면 프로그램이 메모리 상에서 실행될 때 프로세스가 된다.

## 프로세스 상태

프로세스는 실행되면서 상태를 가지고 상황에 따라 여러 상태로 변한다.

프로세스 상태는  활동에 따라 정의된다.

- new : 프로세스가 생성 중인 상태
- running : 명령어들이 실행되고 있는 상태
- blocked(waiting) : 프로세스가 이벤트가 일어나길 기다리는 상태
- ready : 프로세스가 처리기에 할당되기를 기다리는 상태
- terminated : 프로세스 실행이 종료되는 상태
- block suspended : 대기 상태의 프로세스가 메모리 부족으로 일시 중단된 상태
- ready suspended : 준비 상태의 프로세스가 메모리 부족으로 일시 중단된 상태

![프로세스 상태](https://user-images.githubusercontent.com/82176176/206909632-123134b6-7ce2-443a-b8c2-54fbfd86a73c.png)

## 상태 전이

### new → ready

new 상태에서 os에 의해 승인을 받아 프로세스가 생성되고 프로세스가 OS의 Ready Queue에 올라온다.

### ready → running

Ready Queue에 있는 프로세스들 중에서 스케줄러에 의해 프로세스가 CPU에 할당된다.

### running → ready

CPU를 할당 받고 일을 하다가 다른 프로세스에게 CPU를 넘겨주고 다시 CPU 할당을 대기한다.

정해진 시간을 초과하거나, 우선순위가 더 높은 프로세스에 의해 CPU를 넘겨준다.

### running → blocked

프로세스가 I/O 인터럽트로 인해  CPU 반납하고 중단된다.

### blocked → ready

인터럽트가 종료되면 프로세스는 다시 Ready Queue에서 대기하기 된다.

### running → terminated

프로세스가 실행이 완려 되어 자원을 반납한 상태

### new → suspended ready, read → suspended ready, blocked → suspended blocked

메모리 부족으로 인하여 디스크로 swap out된 상태

### suspended ready → ready, suspended blocked → blocked

메모리 공간이 충분하여 디스크로 swap in된 상태

### 프로세스 메모리 구조

## **프로세스의 메모리 배치**

![image](https://user-images.githubusercontent.com/82176176/206909748-3ee7b003-5265-4ae4-8570-39b7becb8cb7.png)

텍스트 섹션 - 실행 코드

데이터 섹션 - 전역 변수, Static 변수 할당

힙 섹션 - 동적으로 할당되는 메모리

### 스택 영역

- 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정되는 동적인 특징
- 스택영역은 동적으로 크기가 늘어날 수 있어 힙과 메모리 영역이 겹치면 안 돼서 공간을 비워 놓는다.

### 힙 영역

- 동적 할당할 때 사용되며 런타임 시 크기가 결정된다.

### 데이터 영역

- 전역변수, 정적(static) 변수가 저장된다.
- 데이터 영역은 BSS 영역과 DATA 영역으로 나뉜다.
- BSS 영역은 초기화되지 않은 변수가 0으로 초기화되어 저장된다.
- DATA 영역은 0이 아닌 다른 값으로 할당된 변수들이 저장된다.

### 텍스트 영역(코드영역)

- 소스 코드가 들어가는 영역이다.


## PCB

프로세스는 운영체제에서 프로세스 제어 블록에 의해 표현이 된다.

프로세스의 메타데이터들이 PCB에 의해 저장되어 관리된다. 

PCB는 다음과 같은 구조로 이루어져 있다.

- 프로세스의 고유 번호
- 프로세스 상태
- 프로세스 권한
- 프로그램 카운터
- CPU 레지스터들
- CPU - 스케줄링 정보
- 메모리 관리 정보
- 프로세스 계정 정보
- 입출력 상태 정보

## **문맥 교환(Context Switch)**

CPU의 할당된 프로세스가 인터럽트로 인해 다른 프로세스로 변경되면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업을 말한다.

문맥은 PCB에 포함되며 문맥 교환을 하면 이전 프로세스의 문맥을 PCB에 저장하고 새로운 프로세스의 PCB를 읽어온다.

![https://blog.kakaocdn.net/dn/dzzyvR/btrK4TuFAjf/DA7QobgA5sEGWpVyfgKXb0/img.png](https://blog.kakaocdn.net/dn/dzzyvR/btrK4TuFAjf/DA7QobgA5sEGWpVyfgKXb0/img.png)

컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생겨 캐시 클리어 과정을 겪게 되고 이 때문에 캐시 미스가 발생한다.

스레드에서도 컨텍스트 스위칭이 일어난다. 

스레드의 컨텍스트 스위칭의 경우 비용이 더 적고 시간이 더 적게 걸립니다.

## **스레드(Thread)**

- CPU 기본 수행 단위이다.
- 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성된다.
- 같은 프로세스의 스레드들은 코드, 데이터 섹션, 운영체제 자원들을 공유한다.

### **단일 스레드**

- 프로세스가 하나의 스레드만을 이용하여 한 번에 하나의 작업만을 수행한다.

### **다중 스레드**

- 프로세스가 여러 개의 스레드로 여러 작업을 수행한다.

![https://blog.kakaocdn.net/dn/myNOi/btrK56f4d4O/A0Tb8O3NPooTHBemiFHgFK/img.png](https://blog.kakaocdn.net/dn/myNOi/btrK56f4d4O/A0Tb8O3NPooTHBemiFHgFK/img.png)

### **다중 스레드 프로그래밍의 장점**

### **응답성**

- 응용프로그램의 긴 작업을 수행할 때 단일 스레드라면 작업이 끝날 때까지 응답을 하지 않는다.
- 다중 스레드를 사용하면 작업을 하면서 사용자에게도 응답을 할 수 있다.

### **자원 공유**

- 프로세스는 공유 메모리나 메시지 패싱을 통해 자원을 공유하지만 스레드는 자신이 속한 프로세스의 자원과 메모리를 공유한다.

### **경제성**

- 프로세스를 새로 생성하는 것은 비용이 많이 든다.
- 스레드를 생성하는 것이 훨씬 경제적이다.

### **규모 적응성**

- 다중 스레드는 다중 처리기 다중 코어 아키텍처가 병렬 실행을 통해 효율적으로 작업을 할 수 있다.

![https://blog.kakaocdn.net/dn/dNik6a/btrK4T2PWpY/XyxUT5A3gVzTzohbAbwvYK/img.png](https://blog.kakaocdn.net/dn/dNik6a/btrK4T2PWpY/XyxUT5A3gVzTzohbAbwvYK/img.png)

## 공유 자원(Shared resource)

- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미한다.

## **경쟁 상태(Race Condition)**

- 여러 개의 프로세스들이 동시에 동일한 데이터에 접근하여 조작을 하고, 실행 결과가 접근 순서에 따라 바뀌는 상황을 경쟁 상황이라고 한다.
- 경쟁 상황으로부터 보호하고 데이터의 일관성을 유지하기 위해 동기화할 필요가 있다.

### **경쟁 상태가 발생하는 경우**

- 커널 모드로 수행 중에 인터럽트가 발생하는 경우
- 커널 모드로 수행 중에 Context switch가 발생하는 경우
- 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근하는 경우

## **임계 영역(Critical Section)**

- 프로세스가 공유 데이터의 접근하는 코드 부분을 말한다.
- 한 프로세스가 임계 영역에서 수행하는 동안 다른 프로세스들이 임계 영역에 들어가지 않게 해야 한다.

### **상호 배제(Mutual Exclusion)**

- 어느 프로세스가 자신의 임계 영역에서 작업을 하면, 다른 프로세스는 자신의 임계 영역이 실행되어선 안된다.

### **진행(Progress)**

- 임계 영역에서 실행되는 프로세스가 없고 자신의 임계 영역으로 진입하려는 프로세스가 있으면 프로세스들은 임계 영역으로 진입 결정에 참여할 수 있다.

### **한정된 대기(Bounded Waiting)**

프로세스가 자신의 임계 구역에 진입을 요청한 후에 무한정 대기할 수 없다.

## **임계 영역 알고리즘**

## **뮤 텍스 락(Mutex Locks)**

- 임계 구역 문제를 해결하기 위한 소프트웨어 도구이다.
- 임계 구역을 보호하고 경쟁 조건을 방지하기 위해 mutex 락을 사용하는데 프로세스는 임계 구역에 들어가기 전에 락을 획득하여야만 들어갈 수 있고 임계 구역을 나올 때 반환한다.
- 뮤 텍스 락은 바쁜 대기(busy waiting)를 해야 하는 단점이 있다.
- 프로세스는 임계 구역을 들어가기 위해 조건을 계속 확인하면서 CPU 메모리를 낭비하게 된다.

## **세마포어(Semaphores)**

- 정수형 변수로 사용할 수 있는 자원의 수를 표현한다.
- 세마포어 변수에 접근할 수 있는 연산은 자원을 가져가는 연산과 자원을 반납하는 연산이 있다.
- 세마포어는 뮤 텍스 락의 Busy Waiting을 해결하기 위해 프로세스를 일시 중지시키고 스케줄링되어 다시 실행된다..

바이너리 세마포어 

- 0과 1 사이의 값만 가능하다.
- 뮤텍스와 유사하지만 뮤텍스는 리소스에 대한 접근을 동기화하는 데 사용하는 잠금 메커니즘이고, 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 메커니즘이다.

카운팅 세모포어 

- 0 이상으로 제한이 없으며 여러 개의 값을 가질 수 있는 세마포어이다.
- 여러 자원에 대한 접근을 제어하는 데 사용한다.

## 모니터(Mornitor)

- 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대한 인터페이스만 제공한다.

## 교착상태(Dead lock)

자원의 잘못된 관리로 인하여 자원을 기다리며 스레드가 대기를 하고 더 이상 상황이 진행되지 않는 상황을 말한다.

![https://blog.kakaocdn.net/dn/BakmY/btrLg8snGYu/bmlBGGHHH8GqFGPWXQH6M1/img.png](https://blog.kakaocdn.net/dn/BakmY/btrLg8snGYu/bmlBGGHHH8GqFGPWXQH6M1/img.png)

## **데드락의 발생 조건**

### **상호 배제**

- 하나의 자원은 한 스레드만이 상용할 수 있다. 다른 스레드가 요청을 하면 자원이 방출될 때까지 기다린다.

### **점유하며 대기**

- 스레드가 자원을 점유하며 다른 자원을 기다릴 때, 보유한 자원을 방출하지 않고 대기한다.

### **비선점**

- 강제적으로 선점되지 않는다. 자원은 스레드가 스스로 방출한다.

### **순환 대기**

- 스레드들이 순환하며 자원을 대기한다. 서로가 서로의 자원을 요구한다.

## **교착상태 예방**

교착상태가 되기 위한 4가의 필요조건 중에 하나의 조건이 발생하지 않게 하여 예방할 수 있다.

### **상호 배제**

- 공유가 불가능한 자원들이 있어 상호 배제 조건을 예방하는 방법은 불가능하다.

### **점유하며 대기**

- 스레드가 실행을 시작하기 전에 모든 자원을 요청하여 할당받거나, 스레드가 자원을 전혀 갖고 잊지 않을 때만 자원을 요청할 수 있도록 허용한다.

### **비선점**

- 스레드가 자원을 점유하며 다른 자원을 요청하고 대기하여야 할 때 현재 가지고 있는 자원을 방출한다. 스레드는 요청한 자원과 보유하고 있던 자원을 획득할 수 있을 때 다시 시작된다.

### **순환 대기**

- 자원의 유형에 순서를 부여하여 프로세스가 순서대로 자원을 할당하게 한다.
