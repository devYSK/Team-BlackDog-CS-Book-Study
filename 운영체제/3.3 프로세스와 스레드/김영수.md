# 3.3 프로세스와 쓰레드



### [프로세스(Process)](https://0soo.tistory.com/120#%ED%--%--%EB%A-%-C%EC%--%B-%EC%-A%A--Process-)

- 사전적 의미 : 일의 과정이나 공정
- 프로그램의 인스턴스, 실행된 프로그램
- 이미 메모리에 적재되어 있음
- 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 됨

### [쓰레드(Thread)](https://0soo.tistory.com/120#%EC%--%B-%EB%A-%--%EB%--%-C-Thread-)

- 한 프로세스 내에서 동시에 실행 가능한 단위
- Java 에서는 JVM 이 모든 thread 관리
- 프로세스라는 작업공간에서 실제로 작업을 처리하는 일꾼
- 프로세스의 자원을 이용해서 작업을 수행함
- 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재
- 쓰레드가 하나(싱글 쓰레드)
- 둘 이상의 쓰레드(멀티 쓰레드)



# 3.3.1 프로세스와 컴파일 과정 



프로세스란, 프로그램으로부터 인스턴스화 된것을 이야기한다.

* 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 됨



프로그램은 컴파일러가 컴파일 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행될 수 있는파일이 되는것을 의미한다.



### 컴파일 과정

프로그램은 컴파일러가 컴파일 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행될 수 있는파일이 되는것을 의미한다.



> ## [컴파일 (Compile) 이란?](https://0soo.tistory.com/59#%EC%BB%B-%ED%-C%-C%EC%-D%BC%---Compile-%--%EC%-D%B-%EB%-E%--%-F)
>
> - 개발자(사용자)가 작성한 소스 코드를 컴퓨터가 이해할 수 있는 언어로 번역하는일.
>   - Java, C, Kotlin와 같은 고급 언어로 작성된 코드를, 컴퓨터가 이해할 수 있게 기계어로 변환하는 과정
>   - 컴파일을 해주는 프로그램을 컴파일러라고 한다.
>
> - 예) Java 파일 컴파일 과정
>   - Java 파일 생성시 .java 확장명을 가진 파일이 생성.
>   - 해당 .java파일을 컴파일 시 .class 파일이 생성
>   - 해당 클래스명을 확장자를 제거하고 입력시 해당 파일이 실행된다.
>   - IDE를 사용하여 실행(run)시 해당 .java 파일은 컴파일되어 .class 파일을 생성하고 해당 파일을 실행시킨다.



# 3.3.2 프로세스의 상태

프로세스의 상태를 여러가지 상태 값을 갖는다

![image-20221211014307412](/Users/ysk/study/devcourse/dev_course_BE/CS스터디/운영체제/images/image-20221211014307412.png)

- **New, Create(생성)**

  - 프로세스가 막 생성된 상태
  - fork() 또는 exec() 함수를 통해 생성하며 이 때 PCB( Process Control Block)이 할당된다
  - fork() : 부모 프로세스의 주소 공간을 그대로 복사하며 새로운 자식 프로세스를 생성하는 함수
    - 주소 공간만 복사할 뿐이지 부모 프로세스의 비동기 작업 등을 상속하지는 않는다
  - exec() : 새롭게 프로세스를 생성하는 함수입니다. 

- **Ready(준비, 대기)**

  * 프로세스가 처리기를 사용하고 있지는 않지만 언제든 사용할 수 있는 상태를 의미

    * 메모리 공간이 충분하면 메모리를 할당받고, 아니면 아닌상태로 대기하고 있다.
    * 프로세스가 처리기의 배정을 기다리고 있는 상태 (CPU스케줄러로부터 소유권이 넘어오기를 기다리는 상태)

    - 다른 프로세스 실행을 위해서 일시적으로 정지해있는 상태

    - CPU에 의해 처리되기 위해 주기억 장치에 존재하는 상태

- **Running(실행)**

  * 프로세스가 CPU를 차지하고 있는 상태 또는 프로세스의 명령이 실행되고 있는 상태를 의미
  * CPU burst가 일어났다고도 표현

- **Suspended Ready**

  * 프로세스가 기억장치를 제외한 다른 모든 필요한 자원을 보유한 상태
  * 메모리 부족으로 일시 중단된 상태.

- Block or Wait( 대기/보류)

  * 프로세스가 어떤 사건(이벤트)이 일어나기를 기다리고 있는 상태. 프로세스가 차단된 상태이다.

  - 처리 속도가 느린 I/O 작업 중인 상태
  - 외부적인 사건이 생길 때까지 실행할 수 없는 상태

- **Blocked Suspended**

  * 프로세스가 대기 상태에서 기억 장치를 잃은(메모리 부족) 상태

  * 대기 중단과 유사하다.

- **Exit(Terminated)**

  - 프로세스의 실행을 완료되고 할당된 CPU를 반납한 상태
  - 비자발적종료(abort)로 종료되는 경우도 있다.
    - 자식 프로세스 할당된 자원의 한계치를 넘어서거나
    - 부모 프로세스가 종료되거나
    - 사용자가 kill 한 상태



### 프로세스 상태 변화

- **Dispatch**(디스패치, 준비실행)
  준비 상태에 있는 여러 프로세스 중 프로세스를 선정하여 CPU를 할당하는 시점
- **Timer Run Out**(할당 시간 종료, 실행준비)
  할당된 시간만큼 CPU를 사용하고 준비 상태로 변하는 시점. 상태 변이 원인이 외부에 있어 외부 인터럽트에 의해 할당 시간이 종료
- **I/O 발생**(Block, 실행대기)
  프로세스가 CPU 사용 중에 I/O 행위가 필요하여 대기 상태로 이동하는 시점
- **Wake up**(대기준비)
  I/O 작업이 완료되거나 자원이 할당되어 다시 준비 상태로 이동하는 시점
- **Suspended**(**Swap-Out**, 대기지연준비)
  준비/대기 상태에서 기억 장치를 반납하고 지연 준비 상태로 전이
- **Resume**(**Swap-In**, 지연 준비대기)
  지연 준비/지연 대기 상태에서 기억 장치를 할당받아 준비(대기) 상태로 전이



# 3.3.3 프로세스의 메모리구조



프로세스는 실행중인 프로그램(program)이 메모리에 적재되어 실행되는것이다.  
이 때 운영체제로 부터 시스템 자원을 할당받는다 



- 할당받는 시스템 자원 :
  - CPU 시간,
  - 운영되기 위한 주소 공간, 파일, 메모리 영역 등
  - 프로세스는 각각 독립된 메모리 영역을 할당 받는다. Code, Data, Stack, Heap의 구조로 되어있는 `독립된 메모리 영역`

<img src="https://blog.kakaocdn.net/dn/egpi9B/btrI1OJXdbh/ZXOY6BzAnnnGqbJqHATVhK/img.png">



| Code 영역  | 실행한 프로그램의 코드가 저장되는 메모리 영역 (프로그램 명령어, 소스 코드 자체) |
| ---------- | ------------------------------------------------------------ |
| Data 영역  | 프로그램의 전역 변수와 static 변수가 저장되는 메모리 영역( 전역변수, static 변수. `정적` ) <br />프로그램이 종료되면 사라지는 변수들이다. <br />- BSS 영역 : 초기화가 되지 않은 변수가 0으로 초기화 되어 저장됨 <br />- Datadㅕㅇ역 : 0이 아닌 다른 값으로 할당된 변수들이 저장됨 |
| Heap 영역  | 프로그래머가 직접 공간을 할당(malloc)/해제(free) 하는 메모리 영역(new() 등 `동적`) |
| Stack 영역 | 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 임시 메모리 영역 (지역변수, 매개변수, 함수, 리턴값 `동적`)  <br />이 때 힙과 스택의 메모리 영역이 겹치면 안 되기 때문에 힙과 스택 사이의 공간을 비워놓는다 |

- 한 프로세스는 다른 프로세스의 자원(변수나 자료구조)에 접근할 수 없다.
  - 다른 프로세스에게 영향을 받지 않는다.
- 접근하려면 `IPC 통신`이 필요하다.

* 스택, 힙 영역은 `동적 영역`  데이터, 코드 영역은 `정적 영역`이다. 



## [PCB (Process Control Block)](https://0soo.tistory.com/15#PCB%---Process%--Control%--Block-)

운영체제에서 프로세스에 메타 데이터들을 저장해 놓는 곳, 한 PCB 안에는 한 프로세스의 정보가 담긴다.

* 프로세스가 생성되면 해당 PCB를 생성한다
* 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리된다.

- **Process Metadata** : 프로세스에 대한 구조화 데이터이자 데이터를 설명하는 작은 데이터. 
  - **Process ID** : 프로세스 ID, 자식 프로세스에 대한 ID
  - **Process State** : 프로세스의 라이프 타임과 관련된 상태로, waiting, running, ready, blocked, end, suspend-wait, suspend-ready 가 있다  
  - **Process Priority** : 프로세스 스케줄링을 위한 우선 순위 
  - **CPU Registers** : 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
    - context switch가 발생하면 이 때의 레지스터 정보를 기억해서 다시 프로세스가 CPU 할당을 받으면 사용한다. accumulator, index, stack pointer 와 같은 레지스터의 값이 저장된다  
  - **Owner** : 프로세스 실행한 유저의 정보 
  - **CPU Usage** :  프로세스 실행에 사용된 CPU 사용량,
  - **Process I/0 status information** : 해당 프로세스가 실행 중에 할당을 요구한 I/O 장치에 대한 정보를 담는다   
  - **Memeory Usage** : 프로세스의 메모리 사용량 



- OS는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다.
- 프로세스는 CPU를 할당받아 작업을 처리하다가 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 한다. 이때 작업의 진행 상황을 모두 PCB에 저장한다. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되었던 내용을 불러와 종료되었던 시점부터 다시 작업을 수행한다.
- PIB는 Linked List 형식으로 관리된다. [참조-PCB](https://whereisusb.tistory.com/12), [참조-PCB](https://velog.io/@hoyun7443/PCB)



### Metadata의 생성과 PCB

이 Metadata는 프로세스가 생성되면 PCB에 저장된다.

1. 프로그램 실행

2. 프로세스 생성 (프로그램을 메모리에 적재)

3. 프로세스 메타 데이터 생성

4. 메타 데이터를 PCB에 저장
   이때, 한 PCB에는 한 프로세스의 정보가 담긴다.

   

### PCB의 필요성과 관리

프로세스가 여러 개 생성될 때, 즉 여러 개의 프로그램이 실행되고 있을 때, CPU는 프로세스의 상태에 따라 교체 작업을 수행한다.

```
교체 작업: Interrupt 발생 -> 할당 받은 프로세스 Waiting 상태로 변경 -> 다른 프로세스를 Running 상태로 변경
```


따라서, 수행 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해 두어야 한다.

PCB는 LinkedList 방식으로 관리되어 삽입과 삭제가 용이하다. 따라서 프로세스가 생성될 때 PCB List Head에 PCB가 삽입되고, 프로세스가 완료되면 PCB가 삭제되는 식으로 관리된다.



## 컨텍스트 스위칭

수행 중인 Task(Process/Thread)가 변경될 때, CPU의 레지스터 정보가 변경되어 PCB를 교환하는과정을 뜻한다. 즉, 이전 프로세스의 상태를 PCB에 보관하고, 다른 프로세스의 정보를 PCB에서 읽어와 CPU 레지스터에 적재하는 과정이다.

* 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생

```
context: CPU가 다루는 프로세스/스레드에 대한 정보로, 대부분 레지스터에 저장되어 있고 PCB로 관리한다.
```



### 스레드의 컨텍스트 스위칭

스레드에서도 컨텍스트 스위칭이 일어난다.

스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭의 경우 비용이 더 적고 시간도 더 적게 걸린다.



## 결론

### PCB의 역할은 무엇인가?

PCB에는 프로세스 ID, 각종 메모리나 중간값과 같은 프로세스 메타 데이터를 저장하는 공간이다. PCB에 저장된 정보를 통해 CPU는 각 프로세스를 구분하고 관리할 수 있으며, Context Switching이 발생하였을 때 이를 이용한다.



### Context Switching이란?

현재 수행 중인 프로세스의 상태 정보를 PCB에 저장하고, 다음 수행할 프로세스의 PCB에서 정보를 읽어와 CPU 레지스터를 세팅하는 과정이다.



### Context Switching은 언제 발생하는가?

실행되고 있는 프로세스가 빠지고 새로운 프로세스가 CPU를 받을 때 발생한다. CPU 스케줄링에 의해 할당된 작업 시간이 끝나 timeout이 발생했거나, 프로세스의 작업이 끝났거나, 실행 중이던 프로세스가 입출력 요청을 하는 등의 이유로 interrupt가 발생했을 때 Context Switching이 이루어진다.



### Context Switching이 왜 필요한가?

CPU는 한 번에 하나의 프로세스만 수행할 수 있지만, 실생활에서 우리는 여러 개의 프로세스를 동시에 수행하고자 한다. 따라서 CPU는 여러 개의 프로세스를 번갈아가면서 수행함으로써 동시에 수행하는 것처럼 보이게 하기 위하여 Context Switching을 사용한다.



# 3.3.5 멀티 프로세싱



- 하나의 응용 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 협력적으로 하나 이상의 작업(`Task`)을 동시에 처리하는 것이다. (병렬처리)
  - 동시성은 CPU core가 1개일 때, 여러 process를 짧은 시간동안 번갈아 가면서 연산을 하게 되는 시분할 시스템(time sharing system)으로 실행되는 것입니다.
  - 병렬성은 CPU core가 여러개일 때, 각각의 core가 각각의 process를 연산함으로써 process가 동시에 실행되는 것입니다.
- 장점
  - 안정성이 확보된다. 여러개의 자식 프로세스 중 하나에 문제가 발생해도 그 자식프로세스만 죽으므로 다른 영향이 가지않는다.
    - 다른 프로세스가 문제가 생겨도 정상적으로 수행된다.
- 단점
  - 프로세스는 각 독립된 메모리 영역을 할당받았기 때문에 공유하는 메모리가 없다.
  - 그래서 작업량이 많을수록 Context Swtiching 이 자주 일어나서 오버헤드가 발생하여 성능 저하
    - 컨텍스트 스위칭이 발생하면 해당 CPU는 그 발생 기간 동안 아무런 작업을 하지 못하므로 오버헤드 발생



### IPC

멀티 프로세스는 IPC (Inter Process Communication)가 가능하며 IPC는 프로세스끼리 데이터를 주고받아 공유 데이터를 관리하는 메커니즘



* 클라이언트와 서버도 IPC의 에이다.

IPC의 종류로는 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐가 있다.

* 이들은 아무리 그래도 메모리가 공유되는 스레드 보다는 속도가 떨어진다



- 프로세스는 `완전히 독립된 실행객체`이기 때문에 IPC를 이용해서 데이터를 주고받아야 한다.
- `커널이 제공하는 IPC 설비`를 통해 프로세스간 통신을 할 수 있다
  - 커널 : 운영체제가 메모리에 상주하는 부분. `운영체제의 핵심적인 부분`



1. 익명 PIPE

> 
>
> 파이프는 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 읽기만 할 수 있다.
>
> 한쪽방향으로만 통신이 가능한 반이중 통신
>
> 통신할 프로세스를 명확히 알 수 있는 경우에 사용.
>
> * 이는 부모, 자식 프로세스간에만 사용 가능. 다른 네트워크상에서는 불가.
>
> 양쪽으로 모두 송/수신을 하고싶으면 2개의 파이프를 만들어야한다. -> 전이중통신
>
> 반이중 통신으로는 매우 간단하게 사용할 수 있는 장점이 있지만, 전이중통신으로 2개를 만들땐 구현이 복잡해짐.



2. Named PILE(FIFO)

> 익명 파이프의 확장된 상태.
>
> 전혀 모르는 상태의 프로세스들 사이 통신에 사용
>
> 동시에 읽기/쓰기가 불가능하므로 익명파이프처럼 2개를 만들어야 가능.



3. Message Queue (메시지 큐)

> 같은점 : 입출력 방식은 Named 파이프와 동일.
>
> 다른점 : 파이프처럼 데이터의 흐름이 아닌 메모리 공간. 어디에서나 물건을 꺼낼 수 있는 컨테이너 벨트라고 보면됨(인덱스로 꺼낼 수 있게)
>
> 사용할 데이터에 번호를 붙여 여러 개의 프로세스가 동시에 데이터를 쉽게 다를 수 있다.



4. Shared Memory (공유 메모리)

> 공유 메모리는 데이터 자체를 공유하도록 지원하는 설비.
>
> 통신을 이용해서 데이터를 주고받는것이 아닌 데이터를 아예 공유해서 함께 사용하는것
>
> 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다.
>
> - **중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동함**
> - 하드웨어 관점에서 공유 메모리는 RAM을 가르키기도 한다.



5. Memory Map (메모리 맵)

> 공유 메모리처럼 메모리를 공유. 열린 파일을 메모리에 맵핑 시켜서 공유하는 방식
>
> (매개채 : 파일. 파일은 시스템이 모두 공유할 수 있는 자원 )



6. 소켓

> 네트워크 소켓 통신을 통해 데이터를 공유
>
> 클라이언트 - 서버 통신 구조
>
> bind - listen - accept
>
> 서버에서 bind - listen - accept를 해주어 연결 준비 - 클라이언트에서는 connect를 통해 서버에 요청 - Socket을 send 하여 데이터를 주고 받음.



7. 메시지 큐

> 메시지를 큐 데이터 구조로 관리하는것을 의미
>
> 이는 커널의 전역변수 형태 등 커널에서 전역적으로 관리되며 다른 IPC 방식에 비해서 사용 방법이 매우 직관적이고 간단하며 다른 코드의 수정 없이 몇줄의 코드를 추가시켜 간단하게 메시지 큐에 접근할 수 있는 장점이 있다.
>
> * 공유 메모리를 통해 IPC를 구현할 때 쓰기 및 읽기 빈도가 높으면 동기화 때문에 기능을 구현하는것이 복잡해지는데 이 때 대안으로 메시지큐 사용



- 이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용한다. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)



# 3.3.6 스레드와 멀티 스레딩

프로세스 내에서 실행되는 여러 흐름의 단위.

즉 프로세스의 실행 단위.

- ![img](https://blog.kakaocdn.net/dn/l0XEi/btrI9l0L3w8/YlPiiP6Y9EinPwG0h8pvO0/img.png) * [이미지출처](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
- 프로세스 내에서 각각 Stack만 따로 할당 받고, Code, Data, Heap 영역은 공유한다
- PC Register(레지스터)도 별도로 갖고있다.
  - 프로세스 간의 자원 공유는 IPC를 이용해야 하지만, 스레드는 Stack영역을 제외한 다른 영역을 공유하기 때문에 자원 공유의 이점을 갖는다.
  - 스레드는 한 프로세스 내에서 동작되는 여려 실행의 프름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에서 스레드끼리 공유하면서 실행된다.
  - 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 유지한다. (프로세스 간의 데이터 공유는 IPC를 통해서만 가능하다)
  - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(Siblind thread)도 `그 결과를 즉시 확인 가능.`
  - 하나의 프로세스에 여러개의 스레드 생성 및 실행이 가능하다.
  - 스레드를 Ligh Weigh Process 라고함
- 하나의 프로세스가 생성될 때 기본적으로 하나의 스레드가 같이 생성
- Stack을 쓰레드마다 독립적으로 할당하는 이유
  - 스택은 함수 호출시 전달되는 매개변수, 되돌아갈 주소값(리턴), 함수 내에서 선언하는 지역 변수 등을 저장하기 위해 사용되는 메모리 공간
  - 스택 메모리 공간이 독립적이라는 것은 `독립적인 함수 호출이 가능`하다는 것
  - 스레드의 정의에 따라 `독립적인 실행 흐름을 추가하기 위한` 최소 조건으로 쓰레드마다 독립적으로 할당한다.
- Register(레지스터)를 쓰레드마다 독립적으로 할당하는 이유
  - PC 레지스터는 명령어를 어디까지 수행하였는지를 나타냄 - > 저장된 상태를 의미
  - 쓰레드도 Context Switching(컨텍스트 스위칭)이 발생하는데 당연히 현재 상태를 모두 저장하고 종료해야 하니 상태값을 저장한다.
  - 명렁어를 어디까지 수행했고 현재 상태를 저장해야 하니 따라서 PC 레지스터를 독립적으로 할당.
- [자바 스레드(Java Thread) 란 - 출처](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
  - 일반 스레드와 거의 차이가 없으며, JVM가 운영체제의 역할을 한다.
  - 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
  - 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.
  - 아래와 같은 스레드와 관련된 많은 정보들도 JVM이 관리한다.
    - 스레드가 몇 개 존재하는지
    - 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지
    - 스레드의 상태는 무엇인지
    - 스레드 우선순위는 얼마인지
  - 즉, 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일 뿐이다.

### [스레드의 장단점](https://0soo.tistory.com/15#%EC%-A%A-%EB%A-%--%EB%--%-C%EC%-D%--%--%EC%-E%A-%EB%-B%A-%EC%A-%--)

- 장점
  - 사용자에 대한 응답성이 향상된다. 왜?
  - 자원 공유가 효율적임 - Data, Code, Heap을 공유하기 때문에.
    - IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요 없다.
    - 프로세스 안에 있으므로 프로세스의 데이터를 모두 접근가능.
  - 그래서 ContextSwitching이 빠르다.
- 단점
  - 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받는다.
    - 모든 프로세스가 종료될 수 있다.
    - 자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수 있따.
  - 컨텍스트 스위칭 효율이 좋아도, 스레드도 너무많이 생성하면 컨텍스트 스위칭 오버헤드로 인해 성능 저하
    - 리눅스에서는 쓰레드를 프로세스와 같이 다루는데 스레드를 많이 생성하면 모든 스레드를 스케쥴링 해야 하니 오버헤드 발생.

- `프로세스는 자신만의 고유공간과 자원을 할당받아 사용하는데 반해, 스레드는 Stack을 제외한 다른스레드와 공간, 자원을 공유하면서 사용하는 차이가 존재`

## [멀티 스레드 (Multi Thread, 멀티 쓰레드)](https://0soo.tistory.com/15#%EB%A-%--%ED%-B%B-%--%EC%-A%A-%EB%A-%--%EB%--%-C%---Multi%--Thread%-C%--%EB%A-%--%ED%-B%B-%--%EC%--%B-%EB%A-%--%EB%--%-C-)

멀티 스레드란 한 프로세스(실행중인 하나의 프로그램) 를 여러개의 쓰레드로 구성하고 각 쓰레드로 하여금 한 작업(task)를 처리하도록 하는 것.

한 프로세스가 동시에 여러개의 일을 수행할 수 있도록 해주는것.

하나의 프로세스에서 여러 작업을 병렬로 처리하는 것이다.

웹 서버는 대표적인 멀티 스레드 응용 프로그램

- 멀티 쓰레드에서는 한 프로세스 내에 여러개의 쓰레드가 있고, 각 쓰레드들은 Stack 메모리를 제외한 Data, Code, Heap 영역을 공유한다.
- 각 쓰레드가 한 프로세스 내에서 독립적인 기능을 수행한다는 것은 독립적으로 함수를 호출하는것
- ![img](https://blog.kakaocdn.net/dn/vp6Ax/btrI9lsWxkx/iSXHMM0MoEjBRJefidvuLK/img.png) * [이미지 출처](http://www.yes24.com/Product/Goods/78225791)
- 장점
  - 효율성이 좋다.
    - 멀티 프로세스(독립적인 프로세스들)에 비해 메모리 공간과 시스템 자원 소모가 줄게 된다
    - 스레드간 통신시 Heap영역을 이용해 데이터를 주고 받으므로 통신이 간단
  - 컨텍스트 스위칭 시 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠르다.
- 단점
  - 안정성에 문제가 있을 수 있다.
    - 하나의 스레드에 문제가 생기면 다른 스레드에도 영향을 끼친다(heap, data, code의 공유 메모리를 갖고있기 때문에.)
    - 프로세스에게로 까지 영향을 끼쳐 프로세스가 종료되면서 전체 쓰레드도 종료될 수 있다.
  - 자원을 공유하기 때문에 `동기화 문제`가 발생한다.

- 해결책
  - Lock(하드웨어 기반): 동시에 공유자원에 접근하는 것을 막기 위해 Critical section에 진입하는 프로세스는 Lock을 획득하고, Critical section을 빠져나올 때, Lock을 반납한다.
  - Semaphores(소프트웨어 기반)
    - 카운팅 세마포: 가용 자원의 개수로 초기화되어, 자원을 사용할 때마다 세마포가 감소하고, 방출하면 세마포를 증가시킨다.
    - 이진 세마포(Mutual Exclusion): 이진수로 초기화되어, 한 개의 스레드만 접근할 수 있다.
    - Deadlock 문제 발생
      - 스레드/프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.
      - 해결책
        - 여러 개의 스레드/프로세스가 공유자원을 이용할 수 있도록 한다.
        - 스레드/프로세스가 실행되기 전 필요한 모든 자원을 할당한다.



## 멀티프로세싱과 멀티스레딩, 그리고 IPC

- 멀티프로세싱 : 여러 개의 ‘프로세스’, 즉 멀티프로세스를 통해 동시에 두 가지 이상의
  일을 수행할 수 있는 것을 말함. 특정 프로세스의 메모리, 프로세스 중 일부에 문제가
  발생되더라도 다른 프로세스를 이용해서 처리할 수 있으므로 신뢰성이 높은 강점
- 멀티스레딩 : 프로세스 내 작업을 멀티스레드로 처리하는 기법이며 스레드끼리 서로
  자원을 공유하기 때문에 효율성이 높음. 동시성에도 큰 장점. 하지만 한 스레드에 문제가
  182 / [인프런- CS지식의 정석]생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수
  있는 단점
- IPC : IPC는 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘을 뜻함.
  클라이언트와 서버를 예로 들 수 있는데, 클라이언트는 데이터를 요청하고 서버는
  클라이언트 요청에 응답하는 것도 포함



# 3.3.7 공유 자원과 임계 영역



### 공유 자원([(Shared Resource)](https://0soo.tistory.com/15#%EA%B-%B-%EC%-C%A-%EC%-E%--%EC%-B%--%---Shared%--Resource-))

시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일,
데이터 등의 자원이나 변수 등

### 경쟁 상태[(Race Condition)](https://0soo.tistory.com/15#%EA%B-%BD%EC%-F%--%EC%--%--%ED%--%-C%---Race%--Condition-)

이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황. 동시에 접근을 시도할 때
접근의 타이밍이나 순서 등이 결괏값에 영향을 줄 수 있는 상태

1. ##### 커널 작업을 수행하는 중에 인터럽트 발생

   - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
   - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.

2. ##### 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환(컨텍스트 스위칭)이 발생할 때

   - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
   - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함

3. ##### 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때

   - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
   - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법



### 임계 영역[Critical Section)](https://0soo.tistory.com/15#%EC%-E%--%EA%B-%--%--%EC%--%--%EC%--%AD-%EC%-E%--%EA%B-%--%--%EA%B-%AC%EC%--%AD%-C%--Critical%--Section-)

공유 자원에 2개 이상의 프로세스나 쓰레드가 접근할 때 경쟁상태가 일어날 수 있는 영역.(접근 순서 등에 결과값을 줄 수 있는 상태)

* 임계영역을 해결하기 위한 방법은 크게 뮤텍스, 세마포어, 모니터 3가지가 있으며 이 방법 모두 상호 배제, 한정 대기, 융통성이란 조건을 만족한다.
  * 상호배제 : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
  * 한정 대기 : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다.
  * 융통성 : 한 프로세스가 다른 프로세스의 일을 방해해서는 안 된다.
* 이 방법에 토대가 되는 메커니즘은 잠금이다.



#### 동기화 문제

동기화 : 한정적인 시스템 자원에 여러 스레드가 동시에 접근하면 문제가 발생할 수 있다.

이 문제를 방지하기 위해 여러 스레드에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정하는 기법

#### [동기화 문제를 해결하기 위한 동기화 기법](https://0soo.tistory.com/15#%EB%-F%--%EA%B-%B-%ED%--%--%--%EB%AC%B-%EC%A-%-C%EB%A-%BC%--%ED%--%B-%EA%B-%B-%ED%--%--%EA%B-%B-%--%EC%-C%--%ED%--%-C%--%EB%-F%--%EA%B-%B-%ED%--%--%--%EA%B-%B-%EB%B-%--)

### [뮤텍스(Mutex) : 상호배제, Mutual exclusion, 이진 세마포어 (bynary semaphore)](https://0soo.tistory.com/15#%EB%AE%A-%ED%--%-D%EC%-A%A--Mutex-%--%-A%--%EC%--%--%ED%--%B-%EB%B-%B-%EC%A-%-C%-C%--Mutual%--exclusion%-C%--%EC%-D%B-%EC%A-%--%--%EC%--%B-%EB%A-%--%ED%-F%AC%EC%--%B-%---bynary%--semaphore-)

- 임계 영역을 가진 스레드들의 실행시간(running time)이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술
- 공유 자원의 데이터를 여러 프로세스, 스레드가 접근하는 것을 막고 프로세스/스레드 수를 `1개로 제한.`!!!
- 공유 자원에 대한 접근을 조율하기 위해 lock, unlock을 사용
  - 락에 대한 소유권이 있으며 락을 가지고 있을 경우에만 공유 자원에 접근할수 있고, 락을 가진 사람만 자원을 반납할 수 있다.
  - lock : 현재 임계 영역에 들어갈 권한을 얻어옴(다른 프로세스나 스레드가 임계 영역 접근중이면 종료할떄까지 대기)
  - unlock: 현재 임계 영역을 모두 사용했음을 알림(대기 중인 다른 프로세스/스레드가 임계 영역에 진입할 수 있다.)
  - `임계 영역에 들어가기 전에 반드시 락을 획득해야 하고 빠져나올때 락을 반납해야 한다`
- 뮤텍스는 락 또는 언락 상태만을 가진다.

### [세마포어(Semaphore)](https://0soo.tistory.com/15#%EC%--%B-%EB%A-%--%ED%-F%AC%EC%--%B--Semaphore-)

- 공유 자원에 데이터를 여러 프로세스, 스레드가 접근하는 것을 막음. - 프로세스 / 스레드의 개수는 2개 이상이 될 수 있다.

- 뮤텍스와의 가장 큰 차이점은, 뮤텍스는 공유 자원에 접근할 수 있는 프로세스/스레드의 개수가 1개 이지만, 세마포어는 2개 이상이 될 수 있다.

- Counter : 동시에 접근할 수 있는 허용 가능한 갯수(공유 자원에 접근할 수 있는 프로세스/스레드의 수를 나타내는 값)

- 세마포어 변수

  - S : S값 만큼 프로세스나 스레드가 접근이 가능하다

  - P(wait 라고도 함) : 검사. S값이 1 이상이면 임계 영역 진입후 S값 1 차감 (0이면 대기)

  - V(signal 라고도 함) : 증가. 임계 영역에서 나올 때 S값을 1 더하고 나온다.

    1. S값이 0보다 크면 임계영역으로 접근이 가능하고, 접근한 다음 S값을 감소한다. S값이 0이라면 다른 프로세스/스레드는 접근할 수 없다.
    2. 임계영역에서 작업을 마치고 나올 떄 S값을 1 증가시킨다.

    - ```stylus
      wait(S)
      // -> 이 영역이 임계 영역(critical section)
      signal(S)
      ```

  - 세마포어 값(S)가 0 또는 1만 가질 수 있는 경우 binary semaphore라고 하고 이는 뮤텍스랑 유사하게 작동한다



#### 바이너리 세마포어

* 0과 1의 두 가지 값만 가질 수 있는 세마포어
* 뮤텍스는 바이너리세마포어라고 할 수 있지만, 엄밀히 말하면 뮤텍스는 잠금을 기반으로 상호배제가 일어나는 '잠금 메커니즘' 이고 세마포어는 신호를 기반으로 상호 배제가 일어나는 '신호 메커니즘'이다.

#### 카운팅 세마포어

* 여러개의 값을 가질 수 있는 세마포어이며 여러 자원에 대한 접근을 제어하는 데 사용 



### [모니터(Monitor)](https://0soo.tistory.com/15#%EB%AA%A-%EB%-B%--%ED%--%B--Monitor-)

- 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체 (추상화된 데이터 형태)
- 공유 자원에 접근하기 위한 키(락) 획득과 해제를 모두 처리한다 ( 자동이다. )

- 뮤텍스와 세마포어 기법의 차이
  - 세마포어는 뮤텍스가 될 수 없지만, 뮤텍스는 세마포어가 될 수 있다.
  - 뮤텍스는 오직 1개의 프로세스/스레드만 공유 자원에 접근할 수 있고, 세마포어는 세마포어 변수(S)값 만큼 프로세스 들이 동시에 자원에 접근할 수 있다.

- 뮤텍스와 모니터의 차이
  - 뮤텍스는 다른 프로세스나 스레드 간에 동기화를 위해 사용
  - 모니터는 하나의 프로세스 내에서 다른 스레드간에 동기화 할 때 사용
  - 뮤텍스는 운영체제 커널에 의해 제공 -> 무겁고 느리다
  - 모니터는 프레임워크나 라이브러리 그 자체에서 제공 -> 가볍고 빠르다

- 모니터와 세마포어 차이
  - 모니터는 세마포어보다 구현하기 쉬우며 상호 배제가 자동인 반면, 세마포어에서는 명시적으로 직접 상호배제를 구현해야 한다.
  - 자바에서는 모니터를 모든 객체에게 기본적으로 제공하지만 C에서는 상요할 수 없음.
  - 세마포어는 카운터 변수(S)를 개발자가 상호 배제나 정렬의 목적으로 사용 시 매번 값을 따로 지정해줘야하는 번거로움이 있음.
    - 모니터는 이러한 일들이 캡슐화 되어 있어서 개발자는 synchronizaed, wait(), notify()등의 키워드를 이용해 좀더 편하게 동기화 가능.



# 3.3.8 교착 상태

- 한정된 자원을 여러 프로세스/스레드에서 사용하려고 할 때 발생하는 문제
- 둘 이상의 스레드가 각기 다른 스레드가 점유하고 있는 자원을 `서로`가 기다릴 때 무한 대기에 빠져 중단된 상황
  - 다음 단계로 진행하지 못하는 상태
- 교착 상태의 발생 조건
  - 상호 배제(Mutext), 점유 대기(hold and Wait), 비선점 (No Preemption), 순환 대기(Circula Wait)이 `동시에 성립할때 발생`.
  - 4가지 조건중 하나라도 성립하지 않는다면 교착상태를 해결할 수 있다. 즉 하나만 해결하면 해결된다.
    1. 상호 배제(Mutual Exclusion)
       - 자원은 한 번에 한 프로세스만이 사용할 수 있다.
    2. 점유와 대기(Hold and Wait)
       - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
    3. 비선점 (No Preemption)
       - 다른 프로세스에 할당된 자원은 사용이 끝나서 반납할 때까지 강제로 빼앗을 수 없다.
    4. 순환 대기 (Circular Wait)
       - 프로세스의 집합 {P0, P1, ..., Pn}에서 0은 1이 점유한 자원을 대기하고 1은 2가 점유한 자원을 대기하고 Pn은 P0이 점유한 자원을 요구해야 한다.
       - 이처럼 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.

- 교착 상태를 해결하는 방법
  - 예방 - 교착 상태 발생 조건 4가지중 하나를 제거함
    - 자원의 상호배제 조건 방지 - 모든 자원을 공유 허용
    - 점유와 대기 조건 방지 - 모든 자원에 대해 선점 허용
    - 비선점 조건 방지 필요 - 자원을 한 번에 모두 할당하기
    - 순환 대기 조건 방지 -자원에게 순서 부여를 통해 프로세스 순서의 증가 방향으로만 자원 요청
    - 단점 : 자원 낭비가 심함

- 은행원 알고리즘
  - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 검사하여 교착 상태를 회피하는 기법이다.
  - 안정 상태에 있으면 자원을 할당하고 그렇지 않으면 다른 프로세스들이 자원을 해제할 때까지 대기한다.

